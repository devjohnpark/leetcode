class Solution {
    // 문제 정의: 
    /*
    1. 각 인덱스의 요소값은 벽의 높이를 나타낸다.
	2. 양쪽에 벽으로 막혀야 물이 고일수 있으므로, 현재 지정한 벽에서 양쪽 벽의 높이를 알아야한다.
	3. 현재 지정한 벽을 기준으로, 왼쪽에서 가장 높은벽과 오른쪽에서 가장 높은 중에서 작은 쪽과의 차이가 물이 고일수있는 양이다.
    */
    // 시간복잡도: O(NlogN) or O(N) -> 배열 순회를 해야하므로 O(N) 일것이다.
    // 직관적 해석
    // 배열을 순회하는 방향으로 이전까지의 최대값과 현재의 값의 차이가 물의 양이다.
    // 하지만 왼쪽과 오른쪽 방향으로 모두 순회해야 이전까지의 최대값과 현재의 값의 차이가 물의 양을 구할수있다.
    // 따라서 투 포인터를 쓰면 양쪽 방향에서 안쪽으로 순회할수있다.
    // 그러면 포인터가 움직이는 방향으로 이전의 최대값과 현재의 값의 차이가 물의 양이다.
    // 그러나 포인터가 움직여서 도달하는 값이 최대값이어야 이전까지의 최대값과 현재의 값의 차이가 물의 양이 된다.
    // 그러므로 양쪽에서 포인터가 최대값으로 이동하는 뱡향이어야한다.
    // 따라서 투 포인터의 이동 조건은 다음과 같다.
    // 1. 왼쪽 최대값이 오른쪽 최대값보다 같거나 작으면 왼쪽 포인터를 오른쪽으로 이동한다.
    // 2. 오른쪽 최대값이 왼족 최대값보다 작으면 오른쪽 포인터를 왼쪽으로 이동한다. 
    public int trap(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int leftMax = height[left]; // 1. 왼쪽 최대값을 첫번째 요소값으로 초기화한다.
        int rightMax = height[right]; // 2. 오른쪽 최대값을 마지막 요소값으로 초기화한다.
        int water = 0;
        // 3. 왼쪽 포인터가 오른쪽 포인터보다 작을 경우 반복한다.
        while (left < right) {
            // 주의점: 현재 조회하는 벽이 이전까지의 벽의 높이와 같거나 높은 경우, 고이는 물이 0이므로 최대값을 구할때 현재 조회하는 벽도 포함시켜야한다. 따라서 현재 조회한 값과 비교해서 왼쪽 오른쪽 최대값을 먼저 구한다.
            leftMax = Math.max(height[left], leftMax);
            rightMax = Math.max(height[right], rightMax);

            if (leftMax <= rightMax) { // 4. 왼쪽 최대값이 오른쪽 최대값보다 작거나 같을 경우, 왼쪽 포인터를 오른쪽으로 이동시키고 물의 양에 `왼쪽 최대값` - `물의 양에 현재 조회한 값` 더한다.

                water += leftMax - height[left];
                left++; 
            } else { // 5. 오른쪽 최대값이 왼쪽 최대값보다 작은 경우, 오른쪽 포인터를 왼쪽으로 이동시키고 물의 양에 `오른쪽 최대값` - `물의 양에 현재 조회한 값` 더한다.
                water += rightMax - height[right];
                right--;
            }
        }
        return water; // 6. 합산된 물의 양을 반환한다.
    }


    // public int trap(int[] height) {
    //     int n = height.length;
    //     int water = 0;
    //     // 1. 배열을 순회하면서 물의 양을 계산할 벽을 지정 (인덱스 지정)
    //     for (int i = 1; i < n - 1; i++) {
    //         // 2. 왼쪽 벽의 최대크기와 오른쪽 벽의 최대크기를 0으로 초기화
    //         int leftMax = 0;
    //         int rightMax = 0;
            
    //         // 주의점: 현재 탐색하는 벽이 제일 높은 경우에 차는 물이 0이므로, 최대값을 구할때 현재 탐색하는 벽도 포함시킨다.
            
    //         // 3. 지정한 벽으로부터 배열을 순회하면서 왼쪽 벽의 최대 크기를 업데이트
    //         for (int j = 0; j <= i; j++) {
    //             leftMax = Math.max(height[j], leftMax);
    //         }
            
    //         // 4. 지정한 벽으로부터 배열을 순회하면서 오른쪽 벽의 최대 크기를 업데이트
    //         for (int k = i; k < n; k++) {
    //             rightMax = Math.max(height[k], rightMax);
    //         }
            
    //         // 5. 물의 양을 구하는 변수에 왼쪽벽과 오른쪽벽 중에서 작은것과 현재 벽의 차이를 더한다.
    //         water += Math.min(leftMax, rightMax) - height[i];	
    //     }
    //     return water;
    // }
}