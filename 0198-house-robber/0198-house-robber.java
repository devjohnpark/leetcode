// 규칙을 찾아라.
// 점화식을 세워라.
// 인접한 요소는 안됨
// 모든 요소가 0이상이므로 조건만 맞으면 모두 더하는게 좋음

// 문제 이해를 잘 못했음
// 두 집 이상을 연속으로 건너뛰었다가 큰 값이 있는 집을 선택하는 편이 더 이득인 예시
// nums = [2, 1, 1, 2]
// 짝수 인덱스 합(0,2): 2 + 1 = 3
// 홀수 인덱스 합(1,3): 1 + 2 = 3
// 하지만 최적 조합은 인덱스 0과 3을 털기: 2 + 2 = 4
// 이러한 조합에 대한 점화식을 세워야한다.
// 이전 집을 털었는지 안털었는지 유무가 현재 집을 털수있는지 결정된다.
// dp[i-1]: i번째 집을 안 턴 경우(그냥 이전까지의 최댓값 유지) 
// dp[i-2] + nums[i]: i번째 집을 터는 경우(인접 제한 때문에 i-2까지의 최댓값에 현재 집 금액 추가)
// dp[i]=max(dp[i−1],dp[i−2]+nums[i])
class Solution {
    public int rob(int[] nums) {
        int prev2 = 0; // dp[i-2]
        int prev1 = 0; // dp[i-1]
        for (int x : nums) {
            int take = prev2 + x;  // 이번 집을 털면 i-2까지 + 현재
            int skip = prev1;      // 이번 집을 안 털면 i-1까지
            int cur = Math.max(take, skip);
            prev2 = prev1;
            prev1 = cur;
        }
        return prev1;
    }
}
