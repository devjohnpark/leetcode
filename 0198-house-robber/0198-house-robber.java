// 1 2 3 1 -> 1 + 3 = 4
// 2 1 1 2 -> 2 + 2 = 4

// 먼저 구하고자 하는 것은 0 ~ i 까지의 털은 집의 최대 금액이다.
// 그러면 4번째 집을 털다면 그전까지의 턴 집의 최대 누적합을 구해야한다.
// 따라서 그전까지의 턴 집의 최대 누적합은 작은 문제이고 앞으로의 턴 집의 최대 누적합이 큰 문제이다.
// 이렇게 큰문제를 작은 문제로 나누고, 작은 문제의 정답은 그것을 포함하는 큰문제에서도 동일하다.
// 이를 통해 DP로 풀어야한다는 것을 알수있다.

// 점화식 세우기
// 이전 집을 털었는지 안털었는지 유무가 현재 집을 털수있는지 결정된다. 즉, 집 i를 털려면 i-1을 못턴다.
// dp[i]: 0 ~ i 집까지 고려했을 때, 털 수 있는 최대 금액
// dp[i-1]: i번째 집을 안 터는 경우, 이전까지의 최댓값 유지
// dp[i-2] + nums[i]: i번째 집을 터는 경우, 인접 제한 때문에 i-2까지의 최댓값에 현재 집 금액 추가
// 따라서 점화식은 dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i])을 성립한다.
// dp[i-2] 때문에 점화식 초기 조건은 2부터이다.
// 따라서 초기 조건이 0일때는 nums[0]이고, 1일때는 nums[0]과 nums[1] 중에서 큰수이다.
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1) return nums[0];

        int dp[] = new int[n];
        
        dp[0] = nums[0];
        dp[1] = Math.max(dp[0], nums[1]);

        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }

        return dp[n - 1];
    }
}