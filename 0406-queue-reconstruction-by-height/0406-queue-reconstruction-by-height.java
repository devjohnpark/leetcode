// 키 내림차순, 같은 키면 k 오름차순
// [[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]

// 정렬된 순서대로 결과 리스트에 k 위치에 삽입
// [7,0] -> [[7,0]]
// [7,1] -> [[7,0],[7,1]]
// [6,1] -> [[7,0],[6,1],[7,1]]
// [5,0] -> [[5,0],[7,0],[6,1],[7,1]]
// [5,2] -> [[5,0],[7,0],[5,2],[6,1],[7,1]]
// [4,4] -> [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]

// 1. 키 내림차순, 같은 키면 k 오름차순: 키가 큰 순서대로 앞에있어야하고 k가 크면 뒤에 있어야하므로
// 2. 정렬된 순서대로 결과 리스트에 k 위치에 삽입 (k는 인덱스를 의미): 이미 앞에 있는 사람들은 모두 자신보다 키가 크거나 같은 사람들이기 때문에 그중 정확히 k명이 앞에 있도록 인덱스 k에 삽입하면 조건 만족
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        // 1. 키 내림차순, 같은 키면 k 오름차순
        Arrays.sort(people, (a, b) -> {
            if (a[0] != b[0]) return b[0] - a[0]; // h 내림차순
            return a[1] - b[1];                   // k 오름차순
        });

        // 2. k 위치에 순서대로 삽입
        List<int[]> list = new ArrayList<>();
        for (int[] p : people) {
            list.add(p[1], p); // 삽입 시, 해당 인덱스에 이미 값이 있으면 그 자리의 원소와 그 뒤의 모든 원소들이 한 칸씩 뒤로 밀린다.
        }

        // 3. 리스트를 배열로 변환
        return list.toArray(new int[people.length][]);
    }
}
